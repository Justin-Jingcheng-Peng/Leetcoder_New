Question,Notes,Status,Categories,Difficulty
21. Merge Two Sorted Lists,"1) Dummy node at the beginning to avoid edge cases. 2) If the pointer of one list reaches the end, just link the ""next"" to the value of the second list.",No help,Linked list,Easy
155. Min Stack,"1) Brute Force solution, I will do it later",No help,Stack,Easy
226. Invert Binary Tree,1) I should treat the base case node be the nullptr. 2) Do not worry about the null right/left-hand side when it is at the recursive step.,With help,Binary Tree,Easy
104. Maximum Depth of Binary Tree,Nothing ,No help,Binary Tree,Easy
206. Reverse Linked List,"1) The problem I faced was the return value is always the ""head"" of the list. However, we need the pointer of the last node to do the concatenation. The solution is easy, since all the values are passed in through pointers, and the memory address is consistent. Thus, we can access head->next, which is the tail of the list we want to concatenate.",With help,Linked list,Easy
217. Contains Duplicate,Introduced a data structure called Set. This data structure has O(1) complexity. It is used often in duplicate questions,With help,Hashmap,Easy
1. Two Sum,Typical hashmap question,With help,Hashmap,Easy
242. Valid Anagram,It is a hashmap question. I created two hashmaps to store the number of occurrences of the two strings. Note that I have to compare if the length of the two strings are the same beforehand,With help,Hashmap,Easy
49. Group Anagrams,"Hashmap question. A few things to point out. 1) hash key can be created by ourselves. In this case, we categorize the words by their unique hash key, which is an array of its char occurrence. We use ord(char) - ord('a') to figure out where in the hash key list the char is supposed to locate. 2) list cannot be used as a hash key, we used tuple(list) instead. 3) We can used hashmap.values() to get a LOL of the values of the hash map. 4) The way to initialize a list with 26 0s is newlist = [0] * 26.",With a lot of help. ,Hashmap,Medium
347. Top K Frequent Elements,"Hashmap question. It can be solved by heap as well. A better solution will be a O(N), using bucket sort algorithm. First I put the frequency into a hashmap. Then, I created a LOL, for which the index stands for the frequency, and the entry is a list of all numbers that have that frequency. Finally I traverse backwards and get the top K elements.",With a lot of help. ,Hashmap,Medium
238. Product of Array Except Self,Pure array question. I iterated the nums forward and backward and accumulated prefix and postfix and store them in the result array.,With a lot of help. ,Array,Medium
36. Valid Sudoku,"Create a HashSet and solve the column and row straightforwardly. For the cell check, just iterate thru it and also use a helper function.",No help,Hashmap,Medium
49. Group Anagrams,"It is a good idea to test 0, 1 and such special cases. Visualizing the data by drawing it out is a very good strategy.",With help,Array,Medium
125. Valid Palindrome,A Two pointer question. I learned isalnum() and .lower() functions. I also learned ord() which gives ASCII value that might be useful.,No help,Two pointers,Easy
167. Two Sum II - Input Array Is Sorted,Straightforward 2-pointer question. Starting from the beginning and the end and get closer to the middle.,No help,Two pointers,Medium
15. 3Sum,"Very challenging question, a few tricks to take notice of. 1) iterate the first element like normal, then the problem changed to a 2 Sum. 2) ""No duplicate"" is the hard part of this question. The first element iteration should not contain duplicates. The way to approach that is to jump the iterator when a series of the same element is occurring. For example [...,2,2,2,...], in this case, only the first 2 should be considered. 3) The ""two sum"" part should also test duplicate like [0,-1,-1,1,1]. It is very important to notice that we don't need to skip both left pointer and right pointer, one is enough. ",With a lot of help. ,Two pointers,Medium
11. Container With Most Water,"Very creative question. The approach is also two pointers. Since we want to maximize both height and width. So we set the two pointers at the two ends. And gradually get closer to the middle. We get closer to the middle by comparing which of the height at the two ends is smaller. Edit: I gave it a second try but still failed. It is easy to figure out that we need to move the two pointers in, but hard to think about how to move.",With a lot of help. ,Two pointers,Medium
121. Best Time to Buy and Sell Stock,"Sliding window. Two cases, if left < right, update left to the position of right, and right to the next of the new left. If right >= left, update right to the next.",With a lot of help. ,Sliding window,Easy
3. Longest Substring Without Repeating Characters,"Sliding window. The two pointers both started at 0. Create a while loop. Inside the loop, first remove the duplicate from the previous window,. Then add to the hash set, update right pointer at the last step. Edit: The approach is very easy to figure out but the implementation is a bit confusing.",With help,Sliding window,Medium
424. Longest Repeating Character Replacement,"Sliding window. Pretty hard and took me around 4 hrs. Defined a helper function to check if the hashmap is a valid hashmap that can be converted to the same char within k changes. Then the main function uses the typical sliding window technique and move forward. For each of the iteration, it sums up the values of the hashmap to track the length of the substring.",No help,Sliding window,Medium
567. Permutation in String,Straightforward. 1) Hashmap remove key: map.pop(key). 2) map1 = {a:0} ,No help,Sliding window,Medium
20. Valid Parentheses,"Stack question. Create a stack first. When there is a left bracket, put it into the stack. When there is a right bracket, use that to ""close"" the top of the stack to ensure the correct order. ",With a lot of help. ,Stack,Easy
155. Min Stack,"Took a few days to figure out the solution. We need to create a helper stack, being used to track the current minium value on the top. Note that even if the current min does not change, we still need to update this stack by adding the same value at the top of the stack. When we delete elements from the stack, we simply just delete the top element from both stacks at the same time.",No help,Stack,Easy
150. Evaluate Reverse Polish Notation,"Create a stack. Iterate through the tokens. When the token is a number, put it into the stack. When the token is an operator, manipulate the last and second last numbers",No help,Stack,Easy
22. Generate Parentheses,"There are many ways this question can be approached. The algorithm is a simple recursion. There are a few important things I learned from the problem. I can create a function inside the function and set a ""global"" list to store all possible strings. In this case, I only need to use ""nonlocal"" to make the variable ""global"" so that this list can be accessed from anywhere. ",With help,Backtracking,Medium
739. Daily Temperatures,"Very hard question. We start from the back. We create a non-strict decreasing stack.  In order to create such a list, we need to pop the top of the stack until stack.top()  > new_entry. In this way, the list will not waste time checking useless value. Also, we have to make pairs in such a form [temp, index] so that the difference between the indexes can be easily calculated.",With a lot of help. ,Stack,Medium
704. Binary Search,"Very simple question about a few things important things. 1) The condition for the loop is (start <= end). 2) The start = mid + 1, end = mid - 1",No help,Binary Search,Easy
74. Search a 2D Matrix,The thing we need to take notice of is that we need to consider both upper bound and lower bound.,With help,Binary Search,Medium
875. Koko Eating Bananas,"The main technique in this question is that we need a global varible outside the loop to tract the current minimum value. Then, we process normal BS and wait it to jump out of the loop by the condition (start <= end)",With a lot of help. ,Binary Search,Medium
33. Search in Rotated Sorted Array,"The hard part of this question is to find the min of the list. The movement of the two pointers are by comparing to the last value of the list, and gradually approach the pivot point. We also need a variable to record the current minimum. We initialize the minimum as min(start, end) because the start and end values are not checked at the beginning. Everytime we take a middle value, we need to compare to the current minimum, and update the current minimum. If luckily the value is indeed the minimum value in the list, we don't need to worry about the rest of the iteration as the value is already found, and we just need to wait the while loop to finish. The worse case is that the two pointers will meet, such as [8,0]. In this case, the algorithm will figure out the minimum when start == end, and they take a middle, then the value will be 0.",No help,Binary Search,Medium
981. Time Based Key-Value Store,"Once the question is understood, the question can be converted to the following. Given a strictly sorted array, find the biggest number smaller where the number is smaller than or equal to the target value. The main technique is very typical, we need a global value being initiated as res = """". Then we update this res when we are implementing BS.  ",With help. ,Binary Search,Medium
66. Plus One,"The question is very straightforward. We need to create a stack and return the inverse of the stack. But we need to consider the carry-on, which is initialized as 0",No help,"Math, Geometry",Easy
206. Reverse Linked List,"The iterative solution is more comprehensive then the recursive solution. I need two pointers, current and previous. I keep updating the two and re-point with the help of a temp.",No help,Linked list,Easy
143. Reorder List,"This is a variation of linked list. The main idea is to split the list into halves. Reverse the second half, then merge the two lists. The technique to find the middle is to initialize a slow ptr at the first node and a fast ptr at the second node. When the fast ptr reaches the end or the fast ptr becomes nullptr, the slow pointer.next is the start of the second half of the list",With help,Linked list,Medium
19. Remove Nth Node From End of List,Not hard. Iterate through the list and count the length. Iterate again and stop at the node before the node we want to remove. Then remove it. Consider the edge case where length == 1; The removed element locates at the head as well.,No help,Linked list,Medium
138. Copy List with Random Pointer,"Challenging question. Three hashmap was set. Map1 maps the adress of node -> its index in the list. With the help of map1, we can create map2, index_cur -> index_random. For example the pair of (2,3) means that in this linked list, the index 2 is pointing at index 3 for the random pointer. Then, we do a deep copy to a new list, but leave the random fields as None temperarily. Then, create another map3, which maps the index to its address. Finally, with the help of map 2 and map3, we can easily set the random field up. Edit: A much simpler solution shoud be mapping the old nodes to the new nodes in the first iteration. In the first iteration, only allocate the memory, no pointer setup at all. In the second interation, use the hashmap to set the pointers. Hashmap: (address of old node -> address of new node)",No help,Linked list,Medium
100. Same Tree,"Base case: case 1: when both nodes are None, return true. Case 2: when one of the nodes are None, return False. Inductive case: return (p.val == q.val) and isTrue(p.left, q.left) and isTrue(p.right, q.right)",No help,Binary Tree,Easy
572. Subtree of Another Tree,"Trivial question. Use the helper function is_same_tree. if the current tree is subtree, return true. Else, recursively search left subtree and right subtree. If it reaches the end, no subtree is found. Return False",No help,Binary Tree,Easy
235. Lowest Common Ancestor of a Binary Search Tree,The key take away in this problem is to understand the difference between binary tree and binary search tree. I did not use the condition where the left nodes are always smaller than the right nodes. So the problem becomes much harder. ,No help,Binary Tree,Easy
141. Linked List Cycle,"Naive solution is putting all the nodes into a hashset. But that has a memory complexity of O(n), which is not good. A better solution uses Floyd's algorithm which setup a fast and slow pointer. If there is a closed loop,   the two pointers will get stuck in the loop and eventually meet.",With help,Linked list,Easy
2. Add Two Numbers,"The algorithm is easy to figure out. The implementation is tricky. The sub-task 1 is to consider both numbers have the same length. In this case, the only think I need to worry about it when it reaches the end, does the carry over exist. The tricky part is when the two numbers have different lengths. In this case, if one number reaches the end, the res list automatically connect to the current pointer of the other list. Then, looping through the rest of the list. One thing to notice is that we need a temp variable to store the current value of the current node. ",No help,Linked list,Medium
287. Find the Duplicate Number,"Did not even understand why the algorithm works, just memorized the solution. Could forget anytime. Need to do it later",With a lot of help. ,Linked list,Medium
543. Diameter of Binary Tree,"A sub-task should be finding the height of the binary tree. The key take-away from this sub problem is that if the node reaches null, it should return -1. Otherwise, it returns the max from left and right plus 1. By the time we do the tree traversal, we evaluate the diameter as well. Basically left_height + right_height + 2. Then, keep putting diameters into a global array. Eventully, linear scan the global array and find the max.",With a lot of help. ,Binary Tree,Easy
110. Balanced Binary Tree,The question is very easy. Basically I first need to create a nested function. I also need to set up a global variable. Then I do a normal find height function. I just need to compare left height and right height in between the function in order to check if the tree is balanced or not.,No help,Binary Tree,Easy
102. Binary Tree Level Order Traversal,"Do a normal search on the tree, however, add a second param ""level"". Create a function to find the height of the tree. And create a 2D empty array for the result. So that for each node being visited, it knows which sub-array it belongs to. Edit: it seems that there is another solution that uses a queue to store all node objects. It is necessary to implement that.",No help,Binary Tree,Medium
199. Binary Tree Right Side View,"Typical binary tree BFS question. Level order. While traversing, add the end to the res list. ",No help,Binary Tree,Medium
1448. Count Good Nodes in Binary Tree,"Create nested function. Create a global variable count. Then search the tree from top to bottom, using preorder traversal. Then pass the current max variable to the next function call",No help,Binary Tree,Medium
98. Validate Binary Search Tree,"The key point of this question is to find the max number at the left sub tree and the min number at the right sub tree. Thw way to do that is to make a left move, and traverse all the way done. Vice versa.",No help,Binary Tree,Medium
230. Kth Smallest Element in a BST,"Using iterative approach, which is important but not as comprehensive as recursive solution. I need to use a stack to keep the previous nodes that will eventually be popped onto",With a lot of help. ,Binary Tree,Medium
105. Construct Binary Tree from Preorder and Inorder Traversal,"Hard. But the code is short. We need to take the first element in preorder as the root. Then we need to use recursion to construct the left and right. We need to find the index of the root in the inorder list. This point is where the two lists are split. Then we split two lists respectively and recursively call the function. The base case is important. When either of the two lists are empty, we need to return Null.",With a lot of help. ,Binary Tree,Medium
208. Implement Trie (Prefix Tree),"A question where the iterative solution is much better than the recursive solution. Starting from the root node and iterative through the string. The defination of the node is important. The node should include a boolean which indicates end of word, and also a hashmap where num -> node. Notice that the last char of a string will point at a node contains an empty hashmap and a boolean of true",With a lot of help. ,Trie,Medium
211. Design Add and Search Words Data Structure,"Hard question. A dfs function should take a node and a string. The recursive call should pass the children and slice the string. The hardest part is to consider to base case. There are two types of base case, first is when the length of the string being sliced into 0, in this case, as long as the current node is EOW, it should return True. The second base case is when there is no more children, in this case, if the string still has a letter, it means the string in the current path is shorter than the string we are searching for. So we should return False.",No help,Trie,Medium
257. Binary Tree Paths,"The dfs function should take current string as well. We cannot wait until the current node is none. Instead, we should consider the base case when the path reaches the leaf node. There are 4 cases for each node, if the node has both left and right children, dfs both children. if there is only one children, dfs right/left child. If there is no children, base case is reaches so just put the value into the list. ",With help,Binary Tree,Easy
703. Kth Largest Element in a Stream,"Heap, which is a new topic. A few important take-aways. Time complexity of heap. Add/delete: O(logn); min: O(1); I also need to remember some heap methods such as heapq.heapify(arr), heapq.heappop(heap), heapq.heappush(heap, val).",With a lot of help. ,Heap,Easy
1046. Last Stone Weight,"I noticed a pattern of using heap data structures. The key work of using heap data structure is ""top k element"". The reason is that we can access the top element in O(1) time complexity, same to a sorted list. But the insertion of sorted list is O(n), which is not that efficient. The complexity of insertion of heap is log(n)",No help,Heap,Easy
973. K Closest Points to Origin,"I just used python default sorting which has nlogn time complexity. The sorting lambda is very good. sorted(arr, key=lambda x:x[0]) is an example of using lambda to compare the first value in the list. Edit: The reason why the heap solution is slightly better is because the time complexity is klogn where k is the number of pop operation.",No help,Sorting,Medium
215. Kth Largest Element in an Array,"The question has a trivial solution which is using a max heap. But the question can be solved with average time complexity of O(N). Quicksort is being used. Process a normal quicksort operation. But recursive call is a litle bit different. We are considering the pivot point and the target point (len(arr) - k), then recursively call the function base on the comparison. ",With a lot of help. ,Sorting,Medium
621. Task Scheduler,"Hard question. Pretty hard to figure out the approach the first time. First, we need a maxHeap to store the number of occurrences. We also need a queue to store the next scheduled time this letter should show up. ",With a lot of help. ,Heap,Medium
23. Merge k Sorted Lists,"The solution of this question is to put the (value, node) pair into a minHeap so that the minimum of the head of the linked list can always be accessed easily. Very important part of the question is that: if we want to heapify (val, node) pairs, we need to add a counter (val, counter, node) in order to prevent duplicate values. ",With help,Heap,Hard
146. LRU Cache,"I am not able to solve this question without decent amount of help. Basically, we need a hashmap like always. But, the key of the hashmap maps to a node that contains key and value. The nodes will form a doubly-linked list. The left of the list is the LRU, and the right is MRU. Everytime we do get and put operation, we need to update the Linked list by using the two helper functions. The two are insert_to_end(node), and remove(node).",With a lot of help. ,Linked list,Medium
78. Subsets,"First actual backtracking question. Using a decision tree. The decision is if the element at the current index should be added into the subset. Each time a decision is made, the dfs function should recursively call the next decision. The ""not add"" decision is made by popping the element that is being added in the previous decision.",With a lot of help. ,Backtracking,Medium
39. Combination Sum,"Hard. I need to consider how to construct the decision tree. The DFS function has three params, the current index, the current array, and the total sum. The decision is whether or not the current element should be put into the recursive function. If not, i will increment and this particular element will never be visited again. Edit on June 28: Gave it a second try, finished with limited hints",With a lot of help. / With help,Backtracking,Medium
46. Permutations,The trick of this question is that I need another array to record all the positions that have been occupied. July 25 edit: Did not solve at the first place but solved with a little hint. Main take away is not to use set for backtracking,No help,Backtracking,Medium
90. Subsets II,"The decision making is important. In order to prevent duplicates. There are two decisions I can make. First, add the current one. Second, do not add the current, and never add the other indexes with the same value as the current. In order to implement this, a sorting operation is required. ",With a lot of help. ,Backtracking,Medium
40. Combination Sum II,"Pretty similar pattern. Decision 1, add the current, jump to the next index. Decision 2, do not add the current, jump to the next different element. One thing that resulted in the bug is the base case, the total_sum == target must come before length restriction i > len(candidates) - 1",No help,Backtracking,Medium
79. Word Search,"Need to apply DFS to this 2D array. Using a nested loop, I need to apply DFS at every single cell. There are two things I need to take notice of but I do not know the reason. First, I need a temp boolean variable to store the recursive dfs, then return the boolean at the very last step. Second, python set is unordered, I can't simply pop it, I need to remove().",With a lot of help. ,Backtracking,Medium
131. Palindrome Partitioning,"The question remind me of a question I did in CS 137, semidrome. The main idea is using a loop to find all the first halves that is a palindrome, then dfs the rest of the string. ",With a lot of help. ,Backtracking,Medium
17. Letter Combinations of a Phone Number,"This question is not hard. A simple backtracking model. But the thing I learned is how the substring works in backtracking. To add a char, I do string = string + char. To remove it, similarly, string = string[:-1}",No help,Backtracking,Medium
51. N-Queens,"The DFS function only takes one param row. Basically, it recursively searches each row. The key to this question is how to track occupied diagonals. We need to track positive diagonals, using (r+c) as the key. Main while, we track negative diagonals, using r-c as the key. We put the keys in the set.",With help,Backtracking,Medium
200. Number of Islands,"First graph question and it is OK. I finished with a little hint. I iterate the graph like I normally do. But I need a helper dfs function. The dfs function can store all the 1s that are connected to the current one. I store all the visited cells in a set. During the iteration, we only increment the counter when the current cell is 1 but not in the visited cells. ",With help,Graph,Medium
417. Pacific Atlantic Water Flow,"Do not use the brute force solution, which is apply DFS at every node. Instead, we can apply DFS at the edge. We need two sets and then find the intersection of these two sets.",With help,Graph,Medium
130. Surrounded Regions,"The solution is elegent and the way of thinking can be applied to many other questions. Instead of thinking about finding all the islands that are isolated from the edge, we can think about it as finding all the islands are connected to the edge, and the rest is natually gonna be the target. Then the solution will be easy to approach",With help,Graph,Medium
994. Rotting Oranges,Straight implementation with BFS. Nothing special,No help,Graph,Medium
663 Â· Walls and Gates,"This question was over complicated. Actually, it is just a simple BFS applying on all the 0 cells. We need a visited set as usual. What I messed up was visited.add, queue.append, and cell value change should all be operated inside the if statement. They work at a whole. We need to put all the 0 cells in the queue and visited as an initialization.",With help,Graph,Medium
207. Course Schedule,"DFS. Learned a lot in this question. It is not an explicit graph question but this linked relationship is giving us a hint that it is a graph question (one depend on many). The DFS is not too hard to figure out as long as we know that a hashmap is a good representation of a graph. While traversing the graph, we are basically trying to test if a node has a route to traverse to the end (reach a node that points to nothing) without getting into a cycle. The cycle detection is proceeded by a hashset. The clean-up after the iteration is very important. We need to not only clean up the hashset, but also set the current hashmap list to empty in order to indicate that this node is a good node, this can improve the efficiency for unnecessary checking. ",With help,Graph,Medium
210. Course Schedule II,"Actually, it is the same idea as the first one but this time adding an element to a list. We need two sets, visited and cycle. Similar to backtracking, we need to process each of the node's children before we pop it out. The dfs function should also return true and false. ",With a lot of help. ,Graph,Medium
684. Redundant Connection,"Introduced a new graph algorithm union find. This is another abstract representation of a graph. There are two lists. One called rank and one called parent. rank[i] represents the size of the tree of node i. parent[i] represents its direct parent. Initially, all the ranks are set to 1, and parent[i] = i, which can be visualized as n different nodes with no connection. Then we need to make connections by union find operations. The find function traces the furthermost root. Union(n1, n2) can combine two graphs. The find function is easy to implement. Just go all the way until parent[i] = i which means the root node is found. The union function is a little bit more complicated. Basically to compare is rank of the root node of the two graphs and determine how the two graphs are merged. The smaller graph should be merged to the bigger graph, by changing its parent to the parent of the bigger graph. Then we need to increment the size of the bigger graph. ",With a lot of help. ,Graph,Medium
70. Climbing Stairs,No need for extra memory. Just inductively solve the Fibonacci series. ,With help,DP,Easy
746. Min Cost Climbing Stairs,An extension of question 70. But need to use min() twice.,No help,DP,Easy
198. House Robber,"Traditional recursion + memoization. The recursion part calls all the indexes except the adjacent index and gets the maximum number from the rest of the array. For the last two indexes, due to the fact that the robber cannot go any further, it returns the number itself. The memoization array needs to be set to optimize the solution. Edit: There is another approach that takes linear space. The solution needs two variables, front and end. The solution takes a linear scan of the array.",No help,DP,Medium
213. House Robber II,Use the Q198 code as a helper function. Run the same function on two sub-arrays. The sub-array excludes the first element and the sub-array excludes the first element.,With a lot of help. ,DP,Medium
5. Longest Palindromic Substring,"I do not know how this question is related to DP. We just need to iterate through the array and consider both even size and odd size palindrome. For the odd size, it is easy to check, we just need to find the center point and radiate outward. For the even part, we just need to combine two adjacent elements to be the center and do the same thing.",With help,DP,Medium
647. Palindromic Substrings,Exact same approach as above,No help,DP,Medium
91. Decode Ways,"An easy question but I overthought it a little bit. Basically recursively call the function on everything except the first element. If the first 2 are valid, I need to recursively call all the elements except the first two as well. Use memoization to store all the recursive calls. ",With help,DP,Medium
322. Coin Change,"Recursion + Memoization. The recursion part is tricky. Give an example of coins [1,2] and seek a target 3. We call dfs(3). Inside this dfs function, we iterate through the coins, and dfs(3-num). So we have dfs(1) and dfs(2). If we ever get dfs(negative), return -1. During the iteration, if we encounter -1, we should continue, which means this choice does not work.",With help,DP,Medium
152. Maximum Product Subarray,The key point of this question is to find the max product and min product starting from a particular index. The reason is that the negative number might mess things up. So our recursive function will return a tuple of max and min.,With help,DP,Medium
139. Word Break,"Same idea as semidrome, which is in the assignment in 1A.",No help,DP,Medium
300. Longest Increasing Subsequence,"Run dfs function on every single index. Inside the dfs function, loop all the indexes after the current index and choose only the ones that are larger than the current. For all those that are larger than the current, we run dfs function on these indexes and return the largest subarray that starts with those indexes. Then we return the maximum plus 1.",No help,DP,Medium
416. Partition Equal Subset Sum,"Tried traditional recursion + memoization solution but got TLE for no reason. Then I tried to iterate through the array and put all possible sums into a HashSet and see if overall_sum // 2 in the hashset, it worked",With a lot of help,DP,Medium
62. Unique Paths,"In order to decrease the time complexity, we do not need a 2D array to store all the values. Instead, we can tackle the question line by line. So the complexity can be reduced to O(min(n*m))",No help,DP,Medium
1143. Longest Common Subsequence,"The approach is very creative. I need a 2D matrix to track the sub-problem and solve the problem using the bottom-up method. We iterate the matrix in reverse order. If the current cell has two chars that match, we return the diagonal + 1, else, return the max of the right adjacent and bottom adjacent.",With a lot of help,DP,Medium
309. Best Time to Buy and Sell Stock with Cooldown,"The dfs function will take two parameters, the first one is current index, the second one is it available for buying or selling. Then in the recursive part of dfs, we need to separate to two differen cases. If it is current buying, we can choose to buy the current one, and find the max profit of the remaining protion, and minus the current one because we spent money to buy the current one. We can cool down and process to the next index. Similarly, if we sell, we can swtich the status to buying and jump the next two index. And leave the second option to cool down.",With a lot of help,DP,Medium
518. Coin Change 2,"A simple backtracking algorithm will work. But a 2D matrix can also be used for the bottom-up solution. To optimize the solution, we can try to reduce the matrix to 2 rows, this is hard",With help,DP,Medium
494. Target Sum,Very easy backtracking. Did not spend a long time solving.,No help,DP,Medium
97. Interleaving String,This is a challenging question. A DP matrix can be used for the bottom-up solution. The outer shell of the matrix should be constructed first. ,With a lot of help,DP,Medium
53. Maximum Subarray,"Solved it myself with DP. But there is a better solution that requires no extra memory. Linearly iterate the array. Before each iteration, check the current sum. If the current sum is less than 0, it means the previous subarray is not helping at all. So we can make the current sum empty and restart.",No help,Greedy,Medium
55. Jump Game,"The greedy solution is smarter than the conventional DP solution. We need to iterate from the back, and gradually move the goal to the front. For example, if we can reach the final index 5 from 4, we just move the goal to 4. Since if any of the previous indexes can jump to 5, it can definitely jump to 4, and then jump to five. So we don't need to consider jumping directly to 5 case.  ",With help,Greedy,Medium
45. Jump Game II,"Used a stupid DP approach at the beginning, which is not efficienct at all. The greedy solution acts similarly to a BFS, or a sliding window. The windoe will start at the first index, and start to move base on the furthest index it can reach.",With a lot of help,Greedy,Medium
134. Gas Station,"This question is not intuitive at all so I just managed to memorize the algorithm. The first part is to calculate the difference between the two arrays and store it in a new list. Then, iterate through the new list. After adding the current value into ""total"", we check if total is smaller than 0, if so, we reset the total to 0 and set the start to be the next index. Then return the start.  ",With a lot of help,Greedy,Medium
846. Hand of Straights,"Did not solve the question at the first place but the solution is intuitive. I need a hashmap the track the frequency of occurrence and a minHeap the help tracking the minimum element.  For each loop, we need to find the smallest current element, then we manage to remove the next N elements base on the given group size. If we fail to find the next N consecutive elements, we return False immediately. If after decrement an element and the number of occurrences turns to 0, we need to remove it from the minHeap. Here is the tricky part of the algorithm. If the number turns to 0 and the top of the minHeap is not this particular element, we need to return False immediately because this case will lead to a future failure. ",With a lot of help,Greedy,Medium
678. Valid Parenthesis String,"Another question that has a tricky algorithm but easy implementation. We need to variables to track what is the maximum number of left bracket we can get and the minimum number of bracket. Two things to take notice of. 1) Everytime when the minimum left bracket becomes negative, we should make it 0. 2) Everytime when the maxium left bracket becomes negative, we return False immediately. ",With a lot of help,Greedy,Medium
763. Partition Labels,"The question can be solved linearly. The most important part is to create a hashmap to track the last existing index. During the iteration, we keep updating the last index if the last index is greater than the current index. If the iterator catches the end variable, it means that the current subarray is valid. Then we empty the current size and begin the new subarray.",With a lot of help,Greedy,Medium
1899. Merge Triplets to Form Target Triplet,"A very intuitive Greedy question and I solved it on my own. Create a cur_tri element to track the current triplet. Then linear scan the array to keep merging the triplets to the current triplets. There are a few things to take notice of. First, if the triplets have any element that is bigger than the target, this triplet can never be merged. Then, as long as there is something in the element that is bigger than the current triplet, we can process a merge. Eventually, we just need to return if the current is identical to the target.",No help,Greedy,Medium
57. Insert Interval,"The question is trickier than it looks. We need to continuously merge. We do a linear scan and compare the current interval to the new interval. If the new interval is completely at the front of the current iteration, we can just add the new interval into the result and add the remaining list, then return the result. if the new interval is completely at the back of the current iteration, we can add the current iteration and continue the looping. Then if there is an overlap, merge the two intervals and store it into the new interval variable, then continue the iteration. After the whole iteration, add the new interval into the result.",With a lot of help,Interval,Medium
56. Merge Intervals,"Create a result array and keep this array representational invariant. When we try to pull an element from intervals, we first check if there is an overlap. We continuously merge the last element of the result until there is no overlapping. When there is no overlapping, we add the accumulated merged interval to the back. ",No help,Interval,Medium
435. Non-overlapping Intervals,"First sort the list. The question is solved by Greedy. When iterating the intervals, we compare the start of this interval and the previous end point to check if there is an overlap. If there is no overlap, we just need to update the end point to the current iterated interval. Otherwise, we need to eliminate one of the two intervals. We need to eliminate the one that extends the most because that one has a greater risk. Therefore, the one with smaller end point will remain and the current end point will be updated to the interval that remains. ",With a lot of help,Interval,Medium
48. Rotate Image,"The key idea of this question is to have a left and right pointer to track the layer. For each layer, we also need a loop to process multiple swapping. Another important part of this question is to store the top left to the temporary variable and work backwards. A suggested approach is to first do not consider to offset an work on the four corner rotating first, then adding the offset should be easy",With a lot of help,"Math, Geometry",Medium
73. Set Matrix Zeroes,"The first approach has a bad time complexity but is easy to understand. The efficient solution is to mark all flipped rows and columns and store them somewhere. The straightforward way to do that is to create O(m+n) extra memory. However, the information can be stored in the same matrix, at the first index instead. But we need one little variable because there is an overlap",No help,"Math, Geometry",Medium
54. Spiral Matrix,"This question is also done by layer. We need 4 variables to track the four boundaries. Each time when we iterate a side (with the existing boundaries), we change the boundary. The important part of the question is to check the condition again in the middle of the iteration to avoid the edge case where the matrix becomes linear. There is an important trick that can be used for the question. Instead of storing them in the list, we can print them out to better visualize it. Also, since the question does not have too many edge cases, we do it by testing edge by edge with 3*4 matrix.",With a lot of help,"Math, Geometry",Medium
202. Happy Number,Used extra memory (set). But I will learn Floyd's method to tmr.  ,No help,"Math, Geometry",Easy
"50. Pow(x, n)",Solved with recursion with O(logn) complexity,With help,"Math, Geometry",Medium
43. Multiply Strings,"Really complicated and used a bunch of helper functions. The general approach is to notice that we can separate the question to one digit multiply a number. This is easier to implement and we can use a helper function to do that. Then we need to add up these results, but in a casscade form. So we need to a function to do that where the swift digit is taken into consideration.",No help,"Math, Geometry",Medium
136. Single Number,XOR all the numers. The duplicated ones will add up to 0 and the only one left will be the target value,With a lot of help,Bit Manipulation,Easy
1584. Min Cost to Connect All Points,"First creating a weighted adjcentency hashmap to represent the graph. Then apply the standard Prim's algorithm. To apply the algorithm, we need to start with a min heap with (0,0).  We also need a visited hashset to track the visited nodes. Prim's algorithm is very similar to BFS. For every iteration, we do a heappop because this element is the one we want to add the the current graph. We also need to make sure this node is not in visited. Then we update the total, and add the current one to visited. Then do the BFS part, which adds all the connections of the current node.",With a lot of help,Graph,Medium
34. Find First and Last Position of Element in Sorted Array,"Perform BS to find right and left respectively. The BS is generally the same as the standard one. But the different part is when the mid value matches the target, it is not necessary the index we want. It might be not RIGHT enough. if the adjecent one also matches the target, we still need to process the BS.",No help,Binary Search,Medium
120. Triangle,A DP question where the space complexity can be optimized with a bottom up solution. We just need a bottom array and keep updating it. We also need a varible i to keep track of which r we are tracking,No help,DP,Medium
338. Counting Bits,Smart way to do it is to list them all and find pattern. Solve it with DP. We need an offset to make it work.,With a lot of help,Bit Manipulation,Medium
24. Swap Nodes in Pairs,Straightfoward swap. Notice to keep track of the previous node. We can use a dummy node to solve the edge cases.,No help,Linked list,Medium
101. Symmetric Tree,"Reverse BT of the right tree, then compare if it is identical to the left tree",No help,Binary Tree,Easy
28. Implement strStr(),"Implemented with O(n^2) time, bad but easy.",No help,String,Easy
69. Sqrt(x),"Variation of BS, but the tricky part is that the final return value should be the end instead of the start. Also the start should be 1 instead of 0. ",With help,"Math, Geometry",Easy
234. Palindrome Linked List,Can be solved in constant space. Fast and slow pointer to get the middle point. Reverse the linked list from the middle pointer and compare if the two halves are the same,With help,Linked list,Easy
236. Lowest Common Ancestor of a Binary Tree,"Solved myself with brute force solution. But an optimized solution can be solved by simple dfs. There are two base cases, if the node reaches None, return None. If the current node is one of the two nodes, then return the current node. Then recursive case, call the recursive function on both left and right. If both returns None, it means there is nothing being found. If left and right both returns target nodes, then return the current node. Otherwise, returns whatever side that is not none.",With help,Binary Tree,Medium
160. Intersection of Two Linked Lists,Jump by the length difference and go straightforwardly.,With help,Linked list,Easy
162. Find Peak Element,"When I see O(logn), we know it is BS. The searching critiria is by seeing if the array is increasing or decreasing. If it is decreasing, we know that there is a local max on its left, if increasing, we know there is a local max on its right. Be aware of the edge cases where the length is 1 or 2. Also be aware the mid pointer is at 0 or len(nums) - 1 where the mid-1 and mid+1 might result in ""out of bound"" issue.",No help,Binary Search,Medium
118. Pascal's Triangle,Trivial  ,No help,"Math, Geometry",Easy
674. Longest Continuous Increasing Subsequence,Trivial two sliding window question. Nothing worth to say,No help,Sliding window,Easy
673. Number of Longest Increasing Subsequence,"Trick question but no more than a 2D DP. Remember the recursive function should return (longest starting from this index, the number of such subsequence)",With help,DP,Medium
124. Binary Tree Maximum Path Sum,"Another case where the return value and actually answer might differ. For each recursive call, the return value has to asssume that there is no turning existing. Therefore, when we call left_max = cur.left and right_max = cur.right. We can guaruntee that the value has no turning. Since we are only allowed to have ONE turning. There are 4 possible cases where result can change. These are the following. cur_node.val; max_left + cur_node.val; max_right + cur_node.val; max_left + max_right + cur_node.val. We need to check all 4 conditions to update the global max.",With help,Binary Tree,Hard
329. Longest Increasing Path in a Matrix,"It is not as hard as a hard question. Basically process the dfs on each single cell. For the dfs function, it will call dfs on its adjcent cells if the cell has a value bigger then the current cell. Then we find the max value of 4 adjcent cells and +1, then return it. If none of the 4 satisfy the condition, we simply return 0 + 1.",No help,DP,Hard
115. Distinct Subsequences,Not hard. Traditional DP question but requires more base cases. Slicing strings are needed,No help,DP,Hard
310. Minimum Height Trees,"The question is processed by keep taking out the outermost layer (leaf nodes) until the graph has only 1 or 2 nodes. This idea is best implemented with BFS algorithm where there is a leaves list to keep track of all the leaf nodes. Then, process the leaf nodes and add a new leaf node if the adjcent node turned to a leaf node. ",With help,Graph,Medium
114. Flatten Binary Tree to Linked List,Good question. The whole process should be done in place. The recursive function should be call on the right and left and both of them return a structure that has already being arranged to linked list. Then we need to spot the end of the left subtree and insert it to the right hand side. Be aware of the edge case where the left subtree returns None.,No help,Binary Tree,Medium
42. Trapping Rain Water,"This is an OK question if not considering space efficiency. For each position, we follow the formula min(maxLeft, maxRight) - height to find the amount of water this position can hold. ",With help,Array,Hard
289. Game of Life,"Not tricky. Notice that while iteration, if we want to turn something to dead, we cannot immediately change it to 0, instead, we change it to ""dead"" to mark that this one is originally live",No help,Array,Medium
429. N-ary Tree Level Order Traversal,"Classic BFS, nothing more",No help,BFS,Medium
122. Best Time to Buy and Sell Stock II,A greedy question that has a really easy implementation but tricky algorithm. If we visitulize the prices as a diagram. We are basically adding up all the positive slopes,With a lot of help,Greedy,Medium
814. Binary Tree Pruning,"Did not take too much time. I need a hasOne function that returns a boolean value. While running the hasOne function, we can delete nodes as necessary.",No help,Binary Tree,Medium
328. Odd Even Linked List,Trivial. Need a status variable to check if I need to move the current node to the back of the list,No help,Linked list,Medium
47. Permutations II,The question requires some creativity where I need to pass a hashmap into the dfs function to remove the duplicates. ,With a lot of help,Backtracking,Medium
96. Unique Binary Search Trees,Simple DP solution. Trick is to not copying the array around and around for the purpose of cache.,No help,DP,Medium
1423. Maximum Points You Can Obtain from Cards,"Orginally came up with a recursive solution but it was too inefficient to pass. Then a prefix/suffix sum solution, still not efficient. The optimal solution should be O(n) where apply a fixed sized sliding window on the array and all the element outside the window are the sum we need to calculate",With help,Sliding window,Medium
221. Maximal Square,"The first impression is pretty tricky. But after I know that It is a DP problem, I figured out. Moreover, it can be solved in place without cache. First we need to construct an outermost shell which contains all 0s. Then we iterate from bottom to top. We need to check all three adjecent cells that are on the right, bottom and bottom right of the current cell and take the min of them. ",With help,DP,Medium
1466. Reorder Routes to Make All Paths Lead to the City Zero,My initial approach is a BFS approach but got stuck because it gets TLEed. The optimization for that is to add another set which contains all the edges so we can access edge information in O(1) time complexity.,With help,BFS,Medium
438. Find All Anagrams in a String,"A standard sliding window question coming with hashmap. It is a fixed sized sliding window and I over complicated that. But it is a good practice about how this type of question works. When the condition is not met, I move the slow pointer and shrink the size. When the condition is met, I move the fast pointer towards the back. Notice that at the starting condition, the fast pointer is always 1 index ahead of the current window.",No help,Sliding window,Medium
718. Maximum Length of Repeated Subarray,"Another practice on the dp bottom up by 2D array. When iterating through the dp, we need to take notice of which one matches which. The iterator ""r"" should match arr1 and ""c"" should match arr2.",With help,DP,Medium
113. Path Sum II,Trivial question. Only thing to notice is that the arr might be over added if the backtracking ends at node == None. The backtracking should end at node == LEAF.,No help,Binary Tree,Medium
1029. Two City Scheduling,A brute-force solution could use DP to track each of the solution. But a better solution uses DP which is hard to come up with. We can calculate the difference and sort them and let the first half going to city A and second half going to city B.,With help,Greedy,Medium